#!/usr/bin/env bash

# Vyn - A Powerful Video Format Converter
# Fast, intuitive video conversion using FFmpeg with interactive CLI
# 
# Repository: https://github.com/samonide/vyn
# Author: samonide
# License: Unlicense
# Version: 1.0.0

set -euo pipefail

# Cleanup function for graceful exit
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        print_warning "Operation interrupted or failed (exit code: $exit_code)"
        print_info "Any partial output files may need to be cleaned up manually."
    fi
    exit $exit_code
}

# Set up signal handling
trap cleanup EXIT
trap 'cleanup' INT TERM

# Script information
readonly SCRIPT_NAME="vyn"
readonly VERSION="1.1.0"
readonly AUTHOR="samonide"
readonly REPOSITORY="https://github.com/samonide/vyn"

# Global variables
declare -g OPERATION_MODE=""
declare -g CRF_VALUE=""
declare -g USE_COLOR=true
declare -g DRY_RUN=false
declare -g BATCH_MODE=false
declare -g AUDIO_ONLY=false
declare -g USE_GPU=false
declare -g GPU_TYPE=""
declare -g CONFIG_FILE="$HOME/.config/vyn/config.conf"
declare -g BATCH_INPUT_DIR=""
declare -g BATCH_OUTPUT_DIR=""
declare -g BATCH_FORMAT=""

# Function to initialize colors based on USE_COLOR setting
init_colors() {
    if [[ "${USE_COLOR}" == true ]]; then
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        PURPLE='\033[0;35m'
        CYAN='\033[0;36m'
        WHITE='\033[1;37m'
        NC='\033[0m' # No Color
    else
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        PURPLE=''
        CYAN=''
        WHITE=''
        NC=''
    fi
}

# Initialize colors
init_colors

# Configuration file functions
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        print_info "ðŸ“„ Loading configuration from $CONFIG_FILE"
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
        print_success "âœ… Configuration loaded"
    fi
}

save_config() {
    local config_dir
    config_dir="$(dirname "$CONFIG_FILE")"
    
    if [[ ! -d "$config_dir" ]]; then
        mkdir -p "$config_dir"
    fi
    
    cat > "$CONFIG_FILE" << EOF
# Vyn Configuration File
# Generated on $(date)

# Default operation mode: remux or encode
DEFAULT_OPERATION_MODE="$OPERATION_MODE"

# Default quality settings for encode mode
DEFAULT_CRF_VALUE="$CRF_VALUE"

# GPU acceleration settings
USE_GPU="$USE_GPU"
GPU_TYPE="$GPU_TYPE"

# UI preferences
USE_COLOR="$USE_COLOR"

# Audio-only mode preference
AUDIO_ONLY="$AUDIO_ONLY"
EOF
    
    print_success "âœ… Configuration saved to $CONFIG_FILE"
}

detect_gpu_acceleration() {
    print_info "ðŸ” Detecting GPU acceleration capabilities..."
    
    # Check for NVIDIA GPU support
    if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "nvenc"; then
        if nvidia-smi &>/dev/null; then
            print_success "ðŸŽ® NVIDIA GPU acceleration available (NVENC)"
            GPU_TYPE="nvenc"
            return 0
        fi
    fi
    
    # Check for AMD/Intel VAAPI support (Linux)
    if [[ "$OSTYPE" == "linux-gnu"* ]] && ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "vaapi"; then
        if [[ -e /dev/dri/renderD128 ]]; then
            print_success "ðŸŽ® VAAPI GPU acceleration available"
            GPU_TYPE="vaapi"
            return 0
        fi
    fi
    
    # Check for Intel QuickSync support
    if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "qsv"; then
        print_info "ðŸŽ® Intel QuickSync may be available"
        GPU_TYPE="qsv"
        return 0
    fi
    
    print_warning "âš ï¸  No GPU acceleration detected"
    return 1
}

# Simple progress indicator
show_progress() {
    local message="$1"
    local pid="$2"
    local chars="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    local i=0
    
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r%s %s" "${chars:$i:1}" "$message"
        i=$(( (i+1) % ${#chars} ))
        sleep 0.1
    done
    printf "\r%s %s\n" "âœ“" "$message"
}

# Enhanced progress bar with animation
show_progress_bar() {
    local message="$1"
    local pid="$2"
    local operation="${3:-Processing}"
    
    local spinner="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    local blocks="â–±â–±â–±â–±â–±â–±â–±â–±â–±â–±"
    local filled="â–ˆ"
    local i=0
    local progress=0
    local start_time=$(date +%s)
    
    while kill -0 "$pid" 2>/dev/null; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        # Create animated progress bar
        local bar=""
        local filled_blocks=$((progress / 10))
        
        for ((j=0; j<10; j++)); do
            if [[ $j -lt $filled_blocks ]]; then
                bar+="${filled}"
            elif [[ $j -eq $filled_blocks ]] && [[ $((i % 3)) -eq 0 ]]; then
                bar+="â–¶"
            else
                bar+="â–±"
            fi
        done
        
        # Display progress
        printf "\r${CYAN}${spinner:$i:1}${NC} ${WHITE}${operation}:${NC} [${GREEN}${bar}${NC}] ${YELLOW}${elapsed}s${NC} ${message}"
        
        # Update counters
        i=$(( (i+1) % ${#spinner} ))
        progress=$(( (progress + 2) % 100 ))
        sleep 0.2
    done
    
    # Final success message
    local final_time=$(date +%s)
    local total_time=$((final_time - start_time))
    local final_bar="${filled}${filled}${filled}${filled}${filled}${filled}${filled}${filled}${filled}${filled}"
    printf "\r${GREEN}âœ“${NC} ${WHITE}${operation} Complete:${NC} [${GREEN}${final_bar}${NC}] ${YELLOW}${total_time}s${NC} ${message}\n"
}

# Batch processing functions
setup_batch_processing() {
    echo ""
    print_color "$PURPLE" "ðŸ—‚ï¸  Batch Processing Setup"
    
    # Get input directory
    while true; do
        read -r -p "ðŸ“ Enter input directory (or type files): " input_path
        if [[ -d "$input_path" ]]; then
            BATCH_INPUT_DIR="$input_path"
            break
        elif [[ -f "$input_path" ]]; then
            print_error "That's a file, not a directory. Please provide a directory path."
        else
            print_error "Directory '$input_path' does not exist!"
        fi
    done
    
    # Get output directory
    while true; do
        read -r -p "ðŸ“¤ Enter output directory: " output_path
        if [[ -n "$output_path" ]]; then
            BATCH_OUTPUT_DIR="$output_path"
            if [[ ! -d "$output_path" ]]; then
                if [[ "$DRY_RUN" == true ]]; then
                    print_info "Would create directory: $output_path"
                else
                    mkdir -p "$output_path"
                    print_success "âœ… Created output directory: $output_path"
                fi
            fi
            break
        else
            print_error "Output directory cannot be empty!"
        fi
    done
    
    # Get target format
    while true; do
        echo ""
        print_color "$PURPLE" "Select target format:"
        echo "1) MP4 (H.264 + AAC)"
        echo "2) MKV (H.264 + AAC)"
        echo "3) WebM (VP9 + Opus)"
        echo "4) Custom format"
        
        read -r -p "Enter your choice (1-4): " format_choice
        case $format_choice in
            1) BATCH_FORMAT="mp4"; break ;;
            2) BATCH_FORMAT="mkv"; break ;;
            3) BATCH_FORMAT="webm"; break ;;
            4) 
                read -r -p "Enter custom format extension (e.g., avi): " custom_format
                if [[ -n "$custom_format" ]]; then
                    BATCH_FORMAT="$custom_format"
                    break
                fi
                ;;
            *) print_error "Invalid choice. Please enter 1-4." ;;
        esac
    done
    
    print_success "âœ… Batch processing configured"
}

process_batch_files() {
    local input_dir="$1"
    local output_dir="$2"
    local target_format="$3"
    
    # Find all video files in input directory
    local video_files=()
    while IFS= read -r -d '' file; do
        video_files+=("$file")
    done < <(find "$input_dir" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.mov" -o -iname "*.webm" -o -iname "*.flv" -o -iname "*.wmv" -o -iname "*.m4v" -o -iname "*.3gp" -o -iname "*.ts" \) -print0)
    
    if [[ ${#video_files[@]} -eq 0 ]]; then
        print_error "No video files found in '$input_dir'"
        exit 1
    fi
    
    print_info "ðŸ“Š Found ${#video_files[@]} video file(s) to process"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "ðŸ” DRY RUN: Batch processing preview"
        for file in "${video_files[@]}"; do
            local basename_file
            basename_file="$(basename "$file")"
            local name_without_ext="${basename_file%.*}"
            local output_file="$output_dir/${name_without_ext}.${target_format}"
            print_info "Would convert: $file â†’ $output_file"
        done
        return 0
    fi
    
    # Process each file
    local processed=0
    local failed=0
    local start_time=$(date +%s)
    
    for file in "${video_files[@]}"; do
        local basename_file
        basename_file="$(basename "$file")"
        local name_without_ext="${basename_file%.*}"
        local output_file="$output_dir/${name_without_ext}.${target_format}"
        
        echo ""
        print_info "ðŸŽ¬ Processing file $((processed + failed + 1))/${#video_files[@]}: $basename_file"
        
        # Skip if output already exists
        if [[ -f "$output_file" ]]; then
            print_warning "âš ï¸  Output file already exists: $output_file (skipping)"
            continue
        fi
        
        # Process the file
        if [[ "$OPERATION_MODE" == "remux" ]]; then
            if do_remux "$file" "$output_file"; then
                ((processed++))
            else
                ((failed++))
                print_error "Failed to process: $file"
            fi
        else
            if do_encode "$file" "$output_file"; then
                ((processed++))
            else
                ((failed++))
                print_error "Failed to process: $file"
            fi
        fi
    done
    
    # Show batch summary
    local end_time=$(date +%s)
    local total_time=$((end_time - start_time))
    
    echo ""
    print_success "ðŸŽ‰ Batch processing completed!"
    print_info "ðŸ“Š Summary:"
    print_info "   âœ… Successfully processed: $processed files"
    if [[ $failed -gt 0 ]]; then
        print_warning "   âŒ Failed: $failed files"
    fi
    print_info "   â±ï¸  Total time: ${total_time}s"
}

# Audio-only processing functions
do_audio_extract() {
    local input="$1"
    local output="$2"
    
    print_info "ðŸŽµ Starting audio extraction..."
    
    # Determine audio codec based on output format
    local output_ext="${output##*.}"
    local audio_codec=""
    local extra_params=""
    
    output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
    
    case "$output_ext" in
        "mp3")
            audio_codec="libmp3lame"
            extra_params="-b:a 320k"
            ;;
        "aac"|"m4a")
            audio_codec="aac"
            extra_params="-b:a 256k"
            ;;
        "ogg")
            audio_codec="libvorbis"
            extra_params="-b:a 256k"
            ;;
        "opus")
            audio_codec="libopus"
            extra_params="-b:a 192k"
            ;;
        "flac")
            audio_codec="flac"
            extra_params=""
            ;;
        "wav")
            audio_codec="pcm_s16le"
            extra_params=""
            ;;
        *)
            audio_codec="aac"
            extra_params="-b:a 256k"
            print_warning "Unknown audio format '$output_ext', using AAC"
            ;;
    esac
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "ðŸ” DRY RUN: Audio extraction preview"
        print_color "$CYAN" "Would execute: ffmpeg -i \"$input\" -vn -c:a $audio_codec $extra_params \"$output\""
        print_info "ðŸŽµ Audio Codec: $audio_codec"
        print_info "âš¡ Operation: Extract audio stream only"
        return 0
    fi
    
    print_color "$CYAN" "ðŸŽµ Audio Codec: $audio_codec"
    print_color "$CYAN" "Command: ffmpeg -i \"$input\" -vn -c:a $audio_codec $extra_params \"$output\""
    echo ""
    
    local start_time=$(date +%s)
    
    # Run FFmpeg for audio extraction
    ffmpeg -i "$input" -vn -c:a "$audio_codec" $extra_params "$output" -y -loglevel error -stats -hide_banner > /tmp/vyn_audio_output.log 2>&1 &
    local ffmpeg_pid=$!
    
    show_progress_bar "$(basename "$input") â†’ $(basename "$output")" "$ffmpeg_pid" "Extracting Audio"
    
    wait $ffmpeg_pid
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        print_success "âœ… Audio extraction completed successfully in ${duration}s!"
        
        if [[ -f "$input" && -f "$output" ]]; then
            show_file_comparison "$input" "$output"
        fi
    else
        echo ""
        print_error "Audio extraction failed!"
        if [[ -f /tmp/vyn_audio_output.log ]]; then
            print_info "Error details:"
            cat /tmp/vyn_audio_output.log
        fi
        exit 1
    fi
}

# Function to print colored output
print_color() {
    local color="$1"
    local message="${2:-}"
    if [[ -n "$message" ]]; then
        printf "${color}${message}${NC}\n"
    else
        # If only one argument provided, treat it as the message with default color
        printf "${1}\n"
    fi
}

# Function to print error messages to stderr
print_error() {
    print_color "$RED" "ERROR: $1" >&2
}

# Function to print warning messages
print_warning() {
    print_color "$YELLOW" "WARNING: $1"
}

# Function to print info messages
print_info() {
    print_color "$CYAN" "INFO: $1"
}

# Function to print success messages
print_success() {
    print_color "$GREEN" "$1"
}

# Function to check if required tools are installed
check_dependencies() {
    local missing_deps=()
    local install_cmd=""
    
    # Check for ffmpeg
    if ! command -v ffmpeg &> /dev/null; then
        missing_deps+=("ffmpeg")
    fi
    
    # Check for jq (optional but recommended)
    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi
    
    # Determine package manager and install command
    if command -v pacman &> /dev/null; then
        install_cmd="sudo pacman -S"
    elif command -v apt &> /dev/null; then
        install_cmd="sudo apt install"
    elif command -v dnf &> /dev/null; then
        install_cmd="sudo dnf install"
    elif command -v brew &> /dev/null; then
        install_cmd="brew install"
    else
        install_cmd="# Use your package manager to install"
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing required dependencies!"
        print_info "Please install the following packages:"
        for dep in "${missing_deps[@]}"; do
            echo "  ${install_cmd} ${dep}"
        done
        echo ""
        print_info "FFmpeg is required for video conversion."
        print_info "jq is optional but provides better file information display."
        exit 1
    fi
}

# Function to show help
show_help() {
    # Header with branding (matching version style)
    echo ""
    printf "${PURPLE}ðŸŽ¬ ${SCRIPT_NAME} v${VERSION}${NC}\n"
    printf "${CYAN}Video. Simplified.${NC}\n"
    echo ""
    
    # Usage section with visual hierarchy
    printf "${GREEN}ðŸ“‹ Usage${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}${SCRIPT_NAME} [input_file] [output_file]${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}${SCRIPT_NAME} [OPTIONS]${NC}\n"
    echo ""
    
    # Options with clean layout
    printf "${GREEN}âš™ï¸  Options${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}-h, --help${NC}       ${YELLOW}Show this help message${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}-v, --version${NC}    ${YELLOW}Show version and dependencies${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}--no-color${NC}       ${YELLOW}Disable colored output${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}--dry-run${NC}        ${YELLOW}Preview operations safely${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}--batch${NC}          ${YELLOW}Batch processing mode${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}--audio-only${NC}     ${YELLOW}Extract audio only${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}--gpu${NC}            ${YELLOW}Enable GPU acceleration${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}--config${NC}         ${YELLOW}Specify config file path${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}--save-config${NC}    ${YELLOW}Save current settings to config${NC}\n"
    echo ""
    
    # Examples section
    printf "${GREEN}ðŸ’¡ Examples${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}${SCRIPT_NAME} input.mkv output.mp4${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}${SCRIPT_NAME} /path/to/video.avi converted.webm${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}${SCRIPT_NAME} --batch${NC} ${YELLOW}# Batch convert directory${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}${SCRIPT_NAME} --audio-only movie.mp4 audio.mp3${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}${SCRIPT_NAME} --gpu input.mkv output.mp4${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}${SCRIPT_NAME} movie.mov${NC} ${YELLOW}# Prompts for output${NC}\n"
    echo ""
    
    # Supported formats
    printf "${GREEN}ðŸ“ Supported Formats${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}Input:${NC}   ${YELLOW}mkv, avi, mov, mp4, webm, flv, wmv, m4v, 3gp, ts${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}Output:${NC}  ${YELLOW}mp4, mkv, webm, avi, mov, m4v${NC}\n"
    echo ""
    
    # Operation modes with icons
    printf "${GREEN}ðŸ”„ Operation Modes${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}âš¡ Remux:${NC}   ${YELLOW}Fast container change (preserves quality)${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}ðŸŽ¯ Encode:${NC}  ${YELLOW}Full conversion with quality control${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}ðŸ—‚ï¸  Batch:${NC}   ${YELLOW}Process multiple files at once${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}ðŸŽµ Audio:${NC}   ${YELLOW}Extract audio tracks only${NC}\n"
    echo ""
    
    # Quality presets
    printf "${GREEN}ðŸŽšï¸  Quality Presets${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}High:${NC}    ${YELLOW}CRF 18 - Excellent quality, large files${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}Good:${NC}    ${YELLOW}CRF 23 - Great quality, balanced (recommended)${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}Medium:${NC}  ${YELLOW}CRF 28 - Good quality, smaller files${NC}\n"
    printf "${CYAN}â”œâ”€${NC} ${WHITE}Low:${NC}     ${YELLOW}CRF 32 - Acceptable quality, very small${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}Custom:${NC}  ${YELLOW}Choose your own CRF value (0-51)${NC}\n"
    echo ""
    
    # Footer with link
    printf "${GREEN}ðŸŒ More Information${NC}\n"
    printf "${CYAN}â””â”€${NC} ${BLUE}${REPOSITORY}${NC}\n"
    echo ""
    
    printf "${GREEN}Made with ${RED}â¤ï¸ ${GREEN} for the community${NC}\n"
    echo ""
}

# Function to show version information
show_version() {
    local ffmpeg_version=$(ffmpeg -version 2>/dev/null | head -n1 | cut -d' ' -f3 || echo "Not found")
    local jq_version=$(jq --version 2>/dev/null || echo "Not found")
    local platform="$(uname -s) $(uname -m)"
    
    # Header with branding
    echo ""
    printf "${PURPLE}ðŸŽ¬ ${SCRIPT_NAME} v${VERSION}${NC}\n"
    printf "${CYAN}Video. Simplified.${NC}\n"
    echo ""
    
    printf "${GREEN}Repository:${NC}  ${YELLOW}${REPOSITORY}${NC}\n"
    printf "${GREEN}License:${NC}     ${YELLOW}Unlicense (Public Domain)${NC}\n"
    printf "${GREEN}Platform:${NC}    ${YELLOW}${platform}${NC}\n"
    echo ""
    
    printf "${GREEN}âš¡ Core Dependencies${NC}\n"
    printf "${CYAN}â”Œâ”€${NC} ${WHITE}FFmpeg:${NC}  ${YELLOW}${ffmpeg_version}${NC}\n"
    printf "${CYAN}â””â”€${NC} ${WHITE}jq:${NC}       ${YELLOW}${jq_version} (optional)${NC}\n"
    echo ""
    
    printf "${GREEN}ðŸ’¡ Quick Start${NC}\n"
    printf "${CYAN}vyn input.mkv output.mp4${NC}\n"
    printf "${CYAN}vyn --help${NC}\n"
    echo ""
    
    printf "${GREEN}ðŸš€ Features:${NC}  ${YELLOW}Fast â€¢ Interactive â€¢ Professional${NC}\n"
    printf "${GREEN}ðŸŽ¯ Modes:${NC}     ${YELLOW}Remux (fast) â€¢ Encode (quality)${NC}\n"
    echo ""
    
    printf "${GREEN}Made with ${RED}â¤ï¸ ${GREEN} for the community${NC}\n"
    echo ""
}

# Function to get file info
get_file_info() {
    local file="$1"
    
    print_color "$CYAN" "ðŸ“ File Information:"
    
    # For dry run with empty/invalid files, show basic info and continue
    if [[ "$DRY_RUN" == true ]] && [[ ! -s "$file" ]]; then
        print_fallback_info "$file"
        return 0
    fi
    
    # Try basic ffprobe first to see if it's a valid media file
    if ! ffprobe -v quiet -show_entries format=duration -of csv="p=0" "$file" &>/dev/null; then
        if [[ "$DRY_RUN" == true ]]; then
            print_fallback_info "$file"
            return 0
        else
            print_fallback_info "$file"
            return 0
        fi
    fi
    
    # Try to get detailed info with jq, fallback to basic info if jq fails
    if command -v jq &> /dev/null; then
        local file_info
        file_info=$(ffprobe -v quiet -print_format json -show_format -show_streams "$file" 2>/dev/null)
        
        if [[ -n "$file_info" ]] && echo "$file_info" | jq empty 2>/dev/null; then
            if ! echo "$file_info" | jq -r '
                .format as $fmt |
                (.streams[] | select(.codec_type=="video")) as $video |
                (.streams[] | select(.codec_type=="audio")) as $audio |
                "  ðŸ“„ File: " + ($fmt.filename | split("/")[-1]) + "\n" +
                "  ðŸ“¦ Container: " + $fmt.format_name + "\n" +
                "  â±ï¸  Duration: " + (if $fmt.duration then (($fmt.duration | tonumber) | strftime("%H:%M:%S")) else "Unknown" end) + "\n" +
                "  ðŸ’¾ Size: " + (if $fmt.size then (($fmt.size | tonumber / 1024 / 1024) | floor | tostring) + " MB" else "Unknown" end) + "\n" +
                (if $video then "  ðŸŽ¬ Video: " + $video.codec_name + " | " + ($video.width | tostring) + "x" + ($video.height | tostring) + " | " + (if $video.r_frame_rate then (($video.r_frame_rate | split("/") | (.[0] | tonumber) / (.[1] | tonumber)) | floor | tostring) + " fps" else "Unknown fps" end) else "  ðŸŽ¬ Video: No video stream found" end) +
                (if $audio then "\n  ðŸ”Š Audio: " + $audio.codec_name + " | " + ($audio.channels | tostring) + " channels" else "\n  ðŸ”Š Audio: No audio stream found" end)
            ' 2>/dev/null; then
                print_fallback_info "$file"
            fi
        else
            print_fallback_info "$file"
        fi
    else
        print_fallback_info "$file"
    fi
    echo ""
}

# Fallback function for basic file info
print_fallback_info() {
    local file="$1"
    echo "  ðŸ“„ File: $(basename "$file")"
    
    if [[ -s "$file" ]]; then
        echo "  ðŸ’¾ Size: $(ls -lh "$file" | awk '{print $5}')"
        
        if command -v ffprobe &> /dev/null; then
            local duration
            duration=$(ffprobe -v quiet -show_entries format=duration -of csv="p=0" "$file" 2>/dev/null)
            if [[ -n "$duration" ]]; then
                local seconds
                seconds=$(echo "$duration" | awk '{print int($1)}')
                local hours=$((seconds / 3600))
                local minutes=$(((seconds % 3600) / 60))
                local secs=$((seconds % 60))
                printf "  â±ï¸  Duration: %02d:%02d:%02d\n" "$hours" "$minutes" "$secs"
            fi
        fi
    else
        echo "  ðŸ’¾ Size: Empty file"
    fi
    
    if [[ "$DRY_RUN" == true ]]; then
        echo "  â„¹ï¸  Note: This is a test file for dry run mode"
    fi
}

# Function to select operation mode
select_operation_mode() {
    echo ""
    print_color $PURPLE "Select Operation Mode:"
    echo "1) Remux (Fast - just change container, no re-encoding)"
    echo "2) Encode (Slower - full conversion with quality options)"
    echo ""
    while true; do
        read -r -p "Enter your choice (1-2): " choice
        case $choice in
            1)
                OPERATION_MODE="remux"
                print_color $GREEN "Selected: Remux (Fast conversion)"
                break
                ;;
            2)
                OPERATION_MODE="encode"
                print_color $GREEN "Selected: Encode (Full conversion)"
                break
                ;;
            *)
                print_color $RED "Invalid choice. Please enter 1 or 2."
                ;;
        esac
    done
}

# Function to select quality for encoding
select_quality() {
    if [ "$OPERATION_MODE" = "encode" ]; then
        echo ""
        print_color $PURPLE "Select Video Quality:"
        echo "1) High Quality (CRF 18 - Large file size)"
        echo "2) Good Quality (CRF 23 - Balanced)"
        echo "3) Medium Quality (CRF 28 - Smaller file)"
        echo "4) Low Quality (CRF 32 - Very small file)"
        echo "5) Custom CRF value"
        echo ""
        while true; do
            read -r -p "Enter your choice (1-5): " quality_choice
            case $quality_choice in
                1)
                    CRF_VALUE="18"
                    print_color $GREEN "Selected: High Quality (CRF 18)"
                    break
                    ;;
                2)
                    CRF_VALUE="23"
                    print_color $GREEN "Selected: Good Quality (CRF 23)"
                    break
                    ;;
                3)
                    CRF_VALUE="28"
                    print_color $GREEN "Selected: Medium Quality (CRF 28)"
                    break
                    ;;
                4)
                    CRF_VALUE="32"
                    print_color $GREEN "Selected: Low Quality (CRF 32)"
                    break
                    ;;
                5)
                    while true; do
                        read -r -p "Enter CRF value (0-51, lower = better quality): " custom_crf
                        if [[ "$custom_crf" =~ ^[0-9]+$ ]] && [ "$custom_crf" -ge 0 ] && [ "$custom_crf" -le 51 ]; then
                            CRF_VALUE="$custom_crf"
                            print_color $GREEN "Selected: Custom Quality (CRF $custom_crf)"
                            break 2
                        else
                            print_color $RED "Invalid CRF value. Please enter a number between 0-51."
                        fi
                    done
                    ;;
                *)
                    print_color $RED "Invalid choice. Please enter 1-5."
                    ;;
            esac
        done
    fi
}

# Function to format file size in human readable format
format_file_size() {
    local size="$1"
    
    if [[ "$size" -eq 0 ]]; then
        echo "0 B"
    elif [[ "$size" -lt 1024 ]]; then
        echo "${size} B"
    elif [[ "$size" -lt $((1024*1024)) ]]; then
        echo "$((size/1024)) KB"
    elif [[ "$size" -lt $((1024*1024*1024)) ]]; then
        echo "$((size/1024/1024)) MB"
    else
        echo "$((size/1024/1024/1024)) GB"
    fi
}

# Function to validate file format compatibility
validate_file_format() {
    local input="$1"
    local output="$2"
    
    # Get file extension
    local input_ext="${input##*.}"
    local output_ext="${output##*.}"
    
    # Convert to lowercase
    input_ext=$(echo "$input_ext" | tr '[:upper:]' '[:lower:]')
    output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
    
    # Define supported input formats
    local supported_input="mp4 mkv avi mov webm m4v flv 3gp wmv mpg mpeg ts"
    local supported_output="mp4 mkv avi mov webm m4v"
    
    # Check input format
    if [[ ! " $supported_input " =~ " $input_ext " ]]; then
        print_warning "âš ï¸  Input format '.$input_ext' may not be fully supported"
        print_info "Supported input formats: $supported_input"
    fi
    
    # Check output format
    if [[ ! " $supported_output " =~ " $output_ext " ]]; then
        print_warning "âš ï¸  Output format '.$output_ext' may not be optimal"
        print_info "Recommended output formats: $supported_output"
    fi
    
    return 0
}

# Function to estimate output file size for dry run
estimate_output_size() {
    local input="$1"
    local operation_mode="$2"
    local crf_value="$3"
    local output_ext="$4"
    
    if [[ ! -s "$input" ]]; then
        echo "Unknown (empty test file)"
        return 0
    fi
    
    local input_size
    if [[ "$OSTYPE" == "darwin"* ]]; then
        input_size=$(stat -f%z "$input" 2>/dev/null || echo "0")
    else
        input_size=$(stat -c%s "$input" 2>/dev/null || echo "0")
    fi
    
    if [[ "$input_size" -eq 0 ]]; then
        echo "Unknown"
        return 0
    fi
    
    local estimated_size=$input_size
    
    if [[ "$operation_mode" == "remux" ]]; then
        # Remux: size usually stays very similar (Â±5%)
        estimated_size=$input_size
        echo "~$(( input_size / 1024 / 1024 )) MB (similar to input)"
    else
        # Encode: estimate based on CRF value and format using bash arithmetic
        local compression_percent
        case "$output_ext" in
            "webm")
                # WebM with VP9 is generally more efficient
                case "$crf_value" in
                    1[0-8]) compression_percent=70 ;;  # High quality - 70% of original
                    1[9-5]) compression_percent=50 ;;  # Good quality - 50% of original
                    2[6-2]) compression_percent=35 ;;  # Medium quality - 35% of original
                    *) compression_percent=25 ;;       # Low quality - 25% of original
                esac
                ;;
            *)
                # H.264 compression estimates
                case "$crf_value" in
                    1[0-8]) compression_percent=80 ;;  # High quality - 80% of original
                    1[9-5]) compression_percent=60 ;;  # Good quality - 60% of original
                    2[6-2]) compression_percent=40 ;;  # Medium quality - 40% of original
                    *) compression_percent=30 ;;       # Low quality - 30% of original
                esac
                ;;
        esac
        
        estimated_size=$(( input_size * compression_percent / 100 ))
        local estimated_mb=$((estimated_size / 1024 / 1024))
        local input_mb=$((input_size / 1024 / 1024))
        local savings=$(( 100 - compression_percent ))
        
        echo "~${estimated_mb} MB (estimated ${savings}% smaller)"
    fi
}
do_remux() {
    local input="$1"
    local output="$2"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "ðŸ” DRY RUN: Remux operation preview"
        print_color "$CYAN" "Would execute: ffmpeg -i \"$input\" -c copy \"$output\""
        print_info "ðŸ“Š Operation: Copy streams without re-encoding"
        print_info "âš¡ Expected speed: Very fast (seconds)"
        print_info "ðŸŽ¯ Quality: Identical to source"
        
        # Show estimated output size
        local output_ext="${output##*.}"
        output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
        local estimated_size=$(estimate_output_size "$input" "remux" "" "$output_ext")
        print_info "ðŸ“¦ Estimated output size: $estimated_size"
        return 0
    fi
    
    print_info "ðŸš€ Starting remux operation..."
    print_color "$CYAN" "Command: ffmpeg -i \"$input\" -c copy \"$output\""
    echo ""
    
    # Record start time for timing
    local start_time=$(date +%s)
    
    # Run FFmpeg in background with progress bar
    ffmpeg -i "$input" -c copy "$output" -y -loglevel error -stats -hide_banner > /tmp/vyn_output.log 2>&1 &
    local ffmpeg_pid=$!
    
    # Show progress bar while FFmpeg runs
    show_progress_bar "$(basename "$input") â†’ $(basename "$output")" "$ffmpeg_pid" "Remuxing"
    
    # Wait for FFmpeg to complete and check result
    wait $ffmpeg_pid
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        print_success "âœ… Remux completed successfully in ${duration}s!"
        
        # Show file size comparison
        if [[ -f "$input" && -f "$output" ]]; then
            show_file_comparison "$input" "$output"
        fi
    else
        echo ""
        print_error "Remux operation failed!"
        print_info "This might happen if the codecs are not compatible with the output container."
        print_info "Try using encode mode instead."
        if [[ -f /tmp/vyn_output.log ]]; then
            print_info "Error details:"
            cat /tmp/vyn_output.log
        fi
        exit 1
    fi
}

# Function to perform encoding
do_encode() {
    local input="$1"
    local output="$2"
    
    # Determine codec based on output format
    local output_ext="${output##*.}"
    local video_codec=""
    local audio_codec=""
    local extra_params=""
    
    # Convert extension to lowercase for comparison
    output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
    
    case "$output_ext" in
        "mp4"|"m4v")
            if [[ "$USE_GPU" == true && "$GPU_TYPE" == "nvenc" ]]; then
                video_codec="h264_nvenc"
                extra_params="-preset fast -rc vbr -cq $CRF_VALUE"
            elif [[ "$USE_GPU" == true && "$GPU_TYPE" == "vaapi" ]]; then
                video_codec="h264_vaapi"
                extra_params="-vaapi_device /dev/dri/renderD128 -vf 'format=nv12,hwupload' -qp $CRF_VALUE"
            else
                video_codec="libx264"
                extra_params="-movflags +faststart"  # Optimize for web streaming
            fi
            audio_codec="aac"
            ;;
        "webm")
            if [[ "$USE_GPU" == true ]]; then
                print_warning "GPU acceleration not widely supported for WebM, using software encoding"
            fi
            video_codec="libvpx-vp9"
            audio_codec="libopus"
            extra_params="-b:v 0 -b:a 128k"  # VBR for VP9
            ;;
        "mkv")
            if [[ "$USE_GPU" == true && "$GPU_TYPE" == "nvenc" ]]; then
                video_codec="h264_nvenc"
                extra_params="-preset fast -rc vbr -cq $CRF_VALUE"
            elif [[ "$USE_GPU" == true && "$GPU_TYPE" == "vaapi" ]]; then
                video_codec="h264_vaapi"
                extra_params="-vaapi_device /dev/dri/renderD128 -vf 'format=nv12,hwupload' -qp $CRF_VALUE"
            else
                video_codec="libx264"
            fi
            audio_codec="aac"
            ;;
        "avi")
            if [[ "$USE_GPU" == true ]]; then
                print_warning "GPU acceleration limited for AVI format, using software encoding"
            fi
            video_codec="libx264"
            audio_codec="aac"
            ;;
        "mov")
            if [[ "$USE_GPU" == true && "$GPU_TYPE" == "nvenc" ]]; then
                video_codec="h264_nvenc"
                extra_params="-preset fast -rc vbr -cq $CRF_VALUE -movflags +faststart"
            elif [[ "$USE_GPU" == true && "$GPU_TYPE" == "vaapi" ]]; then
                video_codec="h264_vaapi"
                extra_params="-vaapi_device /dev/dri/renderD128 -vf 'format=nv12,hwupload' -qp $CRF_VALUE -movflags +faststart"
            else
                video_codec="libx264"
                extra_params="-movflags +faststart"
            fi
            audio_codec="aac"
            ;;
        "flv")
            if [[ "$USE_GPU" == true ]]; then
                print_warning "GPU acceleration not supported for FLV format, using software encoding"
            fi
            video_codec="libx264"
            audio_codec="aac"
            ;;
        "3gp")
            if [[ "$USE_GPU" == true ]]; then
                print_warning "GPU acceleration not supported for 3GP format, using software encoding"
            fi
            video_codec="libx264"
            audio_codec="aac"
            extra_params="-s 320x240"  # Mobile-friendly resolution
            ;;
        *)
            video_codec="libx264"
            audio_codec="aac"
            print_warning "Unknown output format '$output_ext', using default codecs (H.264 + AAC)"
            print_info "Supported formats: mp4, mkv, webm, avi, mov, flv, m4v, 3gp"
            ;;
    esac
    
    print_info "ðŸŽ¬ Starting encode operation..."
    if [[ "$USE_GPU" == true ]]; then
        print_color "$CYAN" "ðŸŽ® GPU Acceleration: $GPU_TYPE | ðŸ“¼ Video Codec: $video_codec | ðŸ”Š Audio Codec: $audio_codec | ðŸŽ¯ CRF: $CRF_VALUE"
    else
        print_color "$CYAN" "ðŸ’» CPU Encoding | ðŸ“¼ Video Codec: $video_codec | ðŸ”Š Audio Codec: $audio_codec | ðŸŽ¯ CRF: $CRF_VALUE"
    fi
    print_color "$CYAN" "Command: ffmpeg -i \"$input\" -c:v $video_codec -crf $CRF_VALUE -c:a $audio_codec $extra_params \"$output\""
    echo ""
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "ðŸ” DRY RUN: Encode operation preview"
        print_info "ðŸ“Š Video Codec: $video_codec (CRF $CRF_VALUE)"
        print_info "ðŸ”Š Audio Codec: $audio_codec"
        print_info "âš¡ Expected speed: Depends on file size and system"
        print_info "ðŸŽ¯ Quality: Based on CRF setting"
        if [[ -n "$extra_params" ]]; then
            print_info "ðŸ”§ Extra parameters: $extra_params"
        fi
        
        # Show estimated output size
        local estimated_size=$(estimate_output_size "$input" "encode" "$CRF_VALUE" "$output_ext")
        print_info "ðŸ“¦ Estimated output size: $estimated_size"
        return 0
    fi
    
    # Show conversion progress indicator
    print_info "ðŸš€ Starting video encoding..."
    print_info "ðŸ“Š Monitor the progress below:"
    echo ""
    
    # Build the command with proper parameters
    local cmd=(
        ffmpeg -i "$input"
    )
    
    # Add GPU-specific parameters before codec selection
    if [[ "$USE_GPU" == true && "$GPU_TYPE" == "vaapi" ]]; then
        cmd+=(-hwaccel vaapi -hwaccel_output_format vaapi)
    elif [[ "$USE_GPU" == true && "$GPU_TYPE" == "nvenc" ]]; then
        cmd+=(-hwaccel cuda -hwaccel_output_format cuda)
    fi
    
    cmd+=(
        -c:v "$video_codec"
    )
    
    # Add CRF or quality parameter based on encoder type
    if [[ "$video_codec" == *"nvenc"* ]]; then
        cmd+=(-cq "$CRF_VALUE")
    elif [[ "$video_codec" == *"vaapi"* ]]; then
        cmd+=(-qp "$CRF_VALUE")
    else
        cmd+=(-crf "$CRF_VALUE")
    fi
    
    cmd+=(
        -c:a "$audio_codec"
        -y
        -loglevel info
        -stats
        -hide_banner
    )
    
    # Add extra parameters if any
    if [[ -n "$extra_params" ]]; then
        # shellcheck disable=SC2206
        cmd+=($extra_params)
    fi
    
    cmd+=("$output")
    
    # Record start time for timing
    local start_time=$(date +%s)
    
    # Run FFmpeg in background with progress bar
    "${cmd[@]}" -loglevel error -stats > /tmp/vyn_output.log 2>&1 &
    local ffmpeg_pid=$!
    
    # Show progress bar while FFmpeg runs
    show_progress_bar "$(basename "$input") â†’ $(basename "$output")" "$ffmpeg_pid" "Encoding"
    
    # Wait for FFmpeg to complete and check result
    wait $ffmpeg_pid
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        print_success "âœ… Encoding completed successfully in ${duration}s!"
        
        # Show file size comparison if input exists
        if [[ -f "$input" && -f "$output" ]]; then
            show_file_comparison "$input" "$output"
        fi
    else
        echo ""
        print_error "Encoding operation failed!"
        print_info "Check the error messages above for details."
        if [[ -f /tmp/vyn_output.log ]]; then
            print_info "Error details:"
            cat /tmp/vyn_output.log
        fi
        exit 1
    fi
}

# Function to show file size comparison
show_file_comparison() {
    local input="$1"
    local output="$2"
    
    echo ""
    print_info "ðŸ“Š File Size Comparison:"
    
    # Get file sizes
    local input_size=$(stat -c%s "$input" 2>/dev/null || echo "0")
    local output_size=$(stat -c%s "$output" 2>/dev/null || echo "0")
    
    # Convert to human readable format
    local input_readable=$(format_file_size "$input_size")
    local output_readable=$(format_file_size "$output_size")
    
    print_info "   Original:  $input_readable"
    print_info "   Converted: $output_readable"
    
    # Calculate compression ratio if both sizes are available
    if [[ "$input_size" -gt 0 && "$output_size" -gt 0 ]]; then
        local ratio=$((output_size * 100 / input_size))
        local savings=$((100 - ratio))
        
        if [[ $ratio -lt 100 ]]; then
            print_success "   ðŸ’¾ Space saved: ${savings}%% (compression ratio: ${ratio}%%)"
        else
            local increase=$((ratio - 100))
            print_warning "   ðŸ“ˆ File size increased by ${increase}%%"
        fi
    fi
    echo ""
}

# Function to show conversion summary
show_summary() {
    local input="$1"
    local output="$2"
    
    if [[ -f "$output" ]]; then
        echo ""
        print_color "$GREEN" "ðŸ“Š Conversion Summary:"
        
        local input_size_human
        local output_size_human
        input_size_human=$(ls -lh "$input" | awk '{print $5}')
        output_size_human=$(ls -lh "$output" | awk '{print $5}')
        
        echo "  ðŸ“¥ Input:  $input_size_human - $input"
        echo "  ðŸ“¤ Output: $output_size_human - $output"
        
        # Calculate size difference with better cross-platform compatibility
        local input_size
        local output_size
        
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            input_size=$(stat -f%z "$input" 2>/dev/null)
            output_size=$(stat -f%z "$output" 2>/dev/null)
        else
            # Linux and others
            input_size=$(stat -c%s "$input" 2>/dev/null)
            output_size=$(stat -c%s "$output" 2>/dev/null)
        fi
        
        if [[ -n "$input_size" && -n "$output_size" ]]; then
            local size_diff=$((output_size - input_size))
            local percent_change
            
            if [[ "$input_size" -gt 0 ]]; then
                percent_change=$(( (size_diff * 100) / input_size ))
                
                if [[ $size_diff -gt 0 ]]; then
                    local size_diff_mb=$((size_diff / 1024 / 1024))
                    print_warning "  ðŸ“ˆ Size change: +${percent_change}%% (+${size_diff_mb}MB larger)"
                elif [[ $size_diff -lt 0 ]]; then
                    local size_diff_mb=$(( (-size_diff) / 1024 / 1024 ))
                    print_success "  ðŸ“‰ Size change: ${percent_change}%% (-${size_diff_mb}MB smaller)"
                else
                    print_info "  âž¡ï¸  Size change: No change"
                fi
            fi
        fi
    fi
}

# Main function
main() {
    local save_config_flag=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --no-color)
                USE_COLOR=false
                init_colors
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --batch)
                BATCH_MODE=true
                shift
                ;;
            --audio-only)
                AUDIO_ONLY=true
                shift
                ;;
            --gpu)
                USE_GPU=true
                shift
                ;;
            --config)
                if [[ -n "${2:-}" && "${2:0:1}" != "-" ]]; then
                    CONFIG_FILE="$2"
                    shift 2
                else
                    print_error "Option --config requires an argument"
                    exit 1
                fi
                ;;
            --save-config)
                save_config_flag=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Use --help for usage information."
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Show help if no arguments provided
    if [[ $# -eq 0 && "$BATCH_MODE" == false ]]; then
        show_help
        exit 0
    fi
    
    # Load configuration file
    load_config
    
    # Check if required dependencies are installed
    check_dependencies
    
    # Handle GPU acceleration setup
    if [[ "$USE_GPU" == true ]]; then
        if ! detect_gpu_acceleration; then
            print_warning "GPU acceleration requested but not available, falling back to CPU"
            USE_GPU=false
        fi
    fi
    
    # Handle batch mode
    if [[ "$BATCH_MODE" == true ]]; then
        setup_batch_processing
        select_operation_mode
        select_quality
        
        echo ""
        print_color "$PURPLE" "ðŸ”§ Batch Conversion Details:"
        echo "  ðŸ“ Input Dir:  $BATCH_INPUT_DIR"
        echo "  ðŸ“¤ Output Dir: $BATCH_OUTPUT_DIR"
        echo "  ðŸ“¦ Format:     $BATCH_FORMAT"
        echo "  âš™ï¸  Mode:       $OPERATION_MODE"
        if [[ "$OPERATION_MODE" == "encode" ]]; then
            echo "  ðŸŽ¯ Quality:    CRF $CRF_VALUE"
        fi
        if [[ "$USE_GPU" == true ]]; then
            echo "  ðŸŽ® GPU:        $GPU_TYPE"
        fi
        
        if [[ "$DRY_RUN" == true ]]; then
            echo ""
            print_info "This is a preview - no files will be modified"
            read -r -p "Continue with preview? (Y/n): " confirm
        else
            echo ""
            read -r -p "Proceed with batch conversion? (Y/n): " confirm
        fi
        
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            print_info "Batch conversion cancelled."
            exit 0
        fi
        
        process_batch_files "$BATCH_INPUT_DIR" "$BATCH_OUTPUT_DIR" "$BATCH_FORMAT"
        
        # Save configuration if requested
        if [[ "$save_config_flag" == true ]]; then
            save_config
        fi
        
        exit 0
    fi
    
    # Get input and output files
    local input_file="$1"
    local output_file="${2:-}"
    
    # Handle audio-only mode
    if [[ "$AUDIO_ONLY" == true ]]; then
        if [[ -z "$output_file" ]]; then
            read -r -p "Enter output audio filename: " output_file
            if [[ -z "$output_file" ]]; then
                print_error "Output filename cannot be empty!"
                exit 1
            fi
        fi
        
        # Validate input file
        if [[ ! -f "$input_file" ]]; then
            print_error "Input file '$input_file' does not exist!"
            exit 1
        fi
        
        # Show file information
        get_file_info "$input_file"
        
        # Confirm audio extraction
        echo ""
        print_color "$PURPLE" "ðŸŽµ Audio Extraction Details:"
        echo "  ðŸ“¥ Input:     $input_file"
        echo "  ðŸ“¤ Output:    $output_file"
        echo "  âš™ï¸  Mode:      Audio-only extraction"
        
        if [[ "$DRY_RUN" == true ]]; then
            echo ""
            print_info "This is a preview - no files will be modified"
            read -r -p "Continue with preview? (Y/n): " confirm
        else
            echo ""
            read -r -p "Proceed with audio extraction? (Y/n): " confirm
        fi
        
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            print_info "Audio extraction cancelled."
            exit 0
        fi
        
        do_audio_extract "$input_file" "$output_file"
        
        # Save configuration if requested
        if [[ "$save_config_flag" == true ]]; then
            save_config
        fi
        
        exit 0
    fi
    
    # Validate input file
    if [[ ! -f "$input_file" ]]; then
        print_error "Input file '$input_file' does not exist!"
        exit 1
    fi
    
    # Check if input file is readable
    if [[ ! -r "$input_file" ]]; then
        print_error "Input file '$input_file' is not readable!"
        print_info "Check file permissions or if the file is being used by another process."
        exit 1
    fi
    
    # If output file not provided, prompt for it
    if [[ -z "$output_file" ]]; then
        echo ""
        read -r -p "Enter output filename: " output_file
        if [[ -z "$output_file" ]]; then
            print_error "Output filename cannot be empty!"
            exit 1
        fi
    fi
    
    # Validate output directory exists and is writable
    local output_dir
    output_dir="$(dirname "$output_file")"
    if [[ ! -d "$output_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            print_info "Would create directory: $output_dir"
        else
            print_info "Creating output directory: $output_dir"
            if ! mkdir -p "$output_dir" 2>/dev/null; then
                print_error "Failed to create output directory '$output_dir'!"
                print_info "Check parent directory permissions."
                exit 1
            fi
            print_success "âœ… Directory created successfully"
        fi
    fi
    
    if [[ ! "$DRY_RUN" == true ]] && [[ ! -w "$output_dir" ]]; then
        print_error "Output directory '$output_dir' is not writable!"
        print_info "Check directory permissions."
        exit 1
    fi
    
    # Check if output file already exists
    if [[ -f "$output_file" ]]; then
        echo ""
        print_warning "Output file '$output_file' already exists!"
        read -r -p "Do you want to overwrite it? (y/N): " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
            print_info "Conversion cancelled."
            exit 0
        fi
    fi
    
    # Show file information
    get_file_info "$input_file"
    
    # Validate file format compatibility
    echo ""
    validate_file_format "$input_file" "$output_file"
    echo ""
    
    # Select operation mode
    select_operation_mode
    
    # Select quality if encoding
    select_quality
    
    # Confirm operation
    echo ""
    if [[ "$DRY_RUN" == true ]]; then
        print_color "$BLUE" "ðŸ” DRY RUN - Preview Mode"
    else
        print_color "$PURPLE" "ðŸ”§ Conversion Details:"
    fi
    echo "  ðŸ“¥ Input:     $input_file"
    echo "  ðŸ“¤ Output:    $output_file"
    echo "  âš™ï¸  Mode:      $OPERATION_MODE"
    if [[ "$OPERATION_MODE" == "encode" ]]; then
        echo "  ðŸŽ¯ Quality:   CRF $CRF_VALUE"
    fi
    if [[ "$USE_GPU" == true ]]; then
        echo "  ðŸŽ® GPU:       $GPU_TYPE"
    fi
    if [[ "$DRY_RUN" == true ]]; then
        echo ""
        print_info "This is a preview - no files will be modified"
        read -r -p "Continue with preview? (Y/n): " confirm
    else
        echo ""
        read -r -p "Proceed with conversion? (Y/n): " confirm
    fi
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            print_info "Preview cancelled."
        else
            print_info "Conversion cancelled."
        fi
        exit 0
    fi
    
    # Record start time
    local start_time
    start_time=$(date +%s)
    
    # Perform conversion or preview
    if [[ "$OPERATION_MODE" == "remux" ]]; then
        do_remux "$input_file" "$output_file"
    else
        do_encode "$input_file" "$output_file"
    fi
    
    # Skip summary and timing for dry run
    if [[ "$DRY_RUN" == true ]]; then
        print_success "ðŸ” Dry run completed successfully!"
        print_info "Use the same command without --dry-run to perform the actual conversion."
        exit 0
    fi
    
    # Calculate duration
    local end_time
    local duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    # Show summary
    show_summary "$input_file" "$output_file"
    
    # Format duration nicely
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    
    if [[ $hours -gt 0 ]]; then
        print_success "ðŸŽ‰ Conversion completed in ${hours}h ${minutes}m ${seconds}s!"
    elif [[ $minutes -gt 0 ]]; then
        print_success "ðŸŽ‰ Conversion completed in ${minutes}m ${seconds}s!"
    else
        print_success "ðŸŽ‰ Conversion completed in ${seconds}s!"
    fi
    
    # Save configuration if requested
    if [[ "$save_config_flag" == true ]]; then
        save_config
    fi
}

# Run main function with all arguments
main "$@"
