#!/usr/bin/env bash

# Vyn - A Powerful Video Format Converter
# Fast, intuitive video conversion using FFmpeg with interactive CLI
# 
# Repository: https://github.com/samonide/vyn
# Author: samonide
# License: Unlicense
# Version: 1.0.0

set -euo pipefail

# Cleanup function for graceful exit
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        print_warning "Operation interrupted or failed (exit code: $exit_code)"
        print_info "Any partial output files may need to be cleaned up manually."
    fi
    exit $exit_code
}

# Set up signal handling
trap cleanup EXIT
trap 'cleanup' INT TERM

# Script information
readonly SCRIPT_NAME="vyn"
readonly VERSION="1.0.1-dev"
readonly AUTHOR="samonide"
readonly REPOSITORY="https://github.com/samonide/vyn"

# Global variables
declare -g OPERATION_MODE=""
declare -g CRF_VALUE=""
declare -g USE_COLOR=true
declare -g DRY_RUN=false

# Function to initialize colors based on USE_COLOR setting
init_colors() {
    if [[ "${USE_COLOR}" == true ]]; then
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        PURPLE='\033[0;35m'
        CYAN='\033[0;36m'
        WHITE='\033[1;37m'
        NC='\033[0m' # No Color
    else
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        PURPLE=''
        CYAN=''
        WHITE=''
        NC=''
    fi
}

# Initialize colors
init_colors

# Simple progress indicator
show_progress() {
    local message="$1"
    local pid="$2"
    local chars="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
    local i=0
    
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r%s %s" "${chars:$i:1}" "$message"
        i=$(( (i+1) % ${#chars} ))
        sleep 0.1
    done
    printf "\r%s %s\n" "‚úì" "$message"
}

# Enhanced progress bar with animation
show_progress_bar() {
    local message="$1"
    local pid="$2"
    local operation="${3:-Processing}"
    
    local spinner="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
    local blocks="‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±"
    local filled="‚ñà"
    local i=0
    local progress=0
    local start_time=$(date +%s)
    
    while kill -0 "$pid" 2>/dev/null; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        # Create animated progress bar
        local bar=""
        local filled_blocks=$((progress / 10))
        
        for ((j=0; j<10; j++)); do
            if [[ $j -lt $filled_blocks ]]; then
                bar+="${filled}"
            elif [[ $j -eq $filled_blocks ]] && [[ $((i % 3)) -eq 0 ]]; then
                bar+="‚ñ∂"
            else
                bar+="‚ñ±"
            fi
        done
        
        # Display progress
        printf "\r${CYAN}${spinner:$i:1}${NC} ${WHITE}${operation}:${NC} [${GREEN}${bar}${NC}] ${YELLOW}${elapsed}s${NC} ${message}"
        
        # Update counters
        i=$(( (i+1) % ${#spinner} ))
        progress=$(( (progress + 2) % 100 ))
        sleep 0.2
    done
    
    # Final success message
    local final_time=$(date +%s)
    local total_time=$((final_time - start_time))
    local final_bar="${filled}${filled}${filled}${filled}${filled}${filled}${filled}${filled}${filled}${filled}"
    printf "\r${GREEN}‚úì${NC} ${WHITE}${operation} Complete:${NC} [${GREEN}${final_bar}${NC}] ${YELLOW}${total_time}s${NC} ${message}\n"
}

# Function to print colored output
print_color() {
    local color="$1"
    local message="${2:-}"
    if [[ -n "$message" ]]; then
        printf "${color}${message}${NC}\n"
    else
        # If only one argument provided, treat it as the message with default color
        printf "${1}\n"
    fi
}

# Function to print error messages to stderr
print_error() {
    print_color "$RED" "ERROR: $1" >&2
}

# Function to print warning messages
print_warning() {
    print_color "$YELLOW" "WARNING: $1"
}

# Function to print info messages
print_info() {
    print_color "$CYAN" "INFO: $1"
}

# Function to print success messages
print_success() {
    print_color "$GREEN" "$1"
}

# Function to check if required tools are installed
check_dependencies() {
    local missing_deps=()
    local install_cmd=""
    
    # Check for ffmpeg
    if ! command -v ffmpeg &> /dev/null; then
        missing_deps+=("ffmpeg")
    fi
    
    # Check for jq (optional but recommended)
    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi
    
    # Determine package manager and install command
    if command -v pacman &> /dev/null; then
        install_cmd="sudo pacman -S"
    elif command -v apt &> /dev/null; then
        install_cmd="sudo apt install"
    elif command -v dnf &> /dev/null; then
        install_cmd="sudo dnf install"
    elif command -v brew &> /dev/null; then
        install_cmd="brew install"
    else
        install_cmd="# Use your package manager to install"
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing required dependencies!"
        print_info "Please install the following packages:"
        for dep in "${missing_deps[@]}"; do
            echo "  ${install_cmd} ${dep}"
        done
        echo ""
        print_info "FFmpeg is required for video conversion."
        print_info "jq is optional but provides better file information display."
        exit 1
    fi
}

# Function to show help
show_help() {
    # Header with branding (matching version style)
    echo ""
    printf "${PURPLE}üé¨ ${SCRIPT_NAME} v${VERSION}${NC}\n"
    printf "${CYAN}Video. Simplified.${NC}\n"
    echo ""
    
    # Usage section with visual hierarchy
    printf "${GREEN}üìã Usage${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}${SCRIPT_NAME} [input_file] [output_file]${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}${SCRIPT_NAME} [OPTIONS]${NC}\n"
    echo ""
    
    # Options with clean layout
    printf "${GREEN}‚öôÔ∏è  Options${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}-h, --help${NC}       ${YELLOW}Show this help message${NC}\n"
    printf "${CYAN}‚îú‚îÄ${NC} ${WHITE}-v, --version${NC}    ${YELLOW}Show version and dependencies${NC}\n"
    printf "${CYAN}‚îú‚îÄ${NC} ${WHITE}--no-color${NC}       ${YELLOW}Disable colored output${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}--dry-run${NC}        ${YELLOW}Preview operations safely${NC}\n"
    echo ""
    
    # Examples section
    printf "${GREEN}üí° Examples${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}${SCRIPT_NAME} input.mkv output.mp4${NC}\n"
    printf "${CYAN}‚îú‚îÄ${NC} ${WHITE}${SCRIPT_NAME} /path/to/video.avi converted.webm${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}${SCRIPT_NAME} movie.mov${NC} ${YELLOW}# Prompts for output${NC}\n"
    echo ""
    
    # Supported formats
    printf "${GREEN}üìÅ Supported Formats${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}Input:${NC}   ${YELLOW}mkv, avi, mov, mp4, webm, flv, wmv, m4v, 3gp, ts${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}Output:${NC}  ${YELLOW}mp4, mkv, webm, avi, mov, m4v${NC}\n"
    echo ""
    
    # Operation modes with icons
    printf "${GREEN}üîÑ Operation Modes${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}‚ö° Remux:${NC}   ${YELLOW}Fast container change (preserves quality)${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}üéØ Encode:${NC}  ${YELLOW}Full conversion with quality control${NC}\n"
    echo ""
    
    # Quality presets
    printf "${GREEN}üéöÔ∏è  Quality Presets${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}High:${NC}    ${YELLOW}CRF 18 - Excellent quality, large files${NC}\n"
    printf "${CYAN}‚îú‚îÄ${NC} ${WHITE}Good:${NC}    ${YELLOW}CRF 23 - Great quality, balanced (recommended)${NC}\n"
    printf "${CYAN}‚îú‚îÄ${NC} ${WHITE}Medium:${NC}  ${YELLOW}CRF 28 - Good quality, smaller files${NC}\n"
    printf "${CYAN}‚îú‚îÄ${NC} ${WHITE}Low:${NC}     ${YELLOW}CRF 32 - Acceptable quality, very small${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}Custom:${NC}  ${YELLOW}Choose your own CRF value (0-51)${NC}\n"
    echo ""
    
    # Footer with link
    printf "${GREEN}üåê More Information${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${BLUE}${REPOSITORY}${NC}\n"
    echo ""
    
    printf "${GREEN}Made with ${RED}‚ù§Ô∏è ${GREEN} for the community${NC}\n"
    echo ""
}

# Function to show version information
show_version() {
    local ffmpeg_version=$(ffmpeg -version 2>/dev/null | head -n1 | cut -d' ' -f3 || echo "Not found")
    local jq_version=$(jq --version 2>/dev/null || echo "Not found")
    local platform="$(uname -s) $(uname -m)"
    
    # Header with branding
    echo ""
    printf "${PURPLE}üé¨ ${SCRIPT_NAME} v${VERSION}${NC}\n"
    printf "${CYAN}Video. Simplified.${NC}\n"
    echo ""
    
    printf "${GREEN}Repository:${NC}  ${YELLOW}${REPOSITORY}${NC}\n"
    printf "${GREEN}License:${NC}     ${YELLOW}Unlicense (Public Domain)${NC}\n"
    printf "${GREEN}Platform:${NC}    ${YELLOW}${platform}${NC}\n"
    echo ""
    
    printf "${GREEN}‚ö° Core Dependencies${NC}\n"
    printf "${CYAN}‚îå‚îÄ${NC} ${WHITE}FFmpeg:${NC}  ${YELLOW}${ffmpeg_version}${NC}\n"
    printf "${CYAN}‚îî‚îÄ${NC} ${WHITE}jq:${NC}       ${YELLOW}${jq_version} (optional)${NC}\n"
    echo ""
    
    printf "${GREEN}üí° Quick Start${NC}\n"
    printf "${CYAN}vyn input.mkv output.mp4${NC}\n"
    printf "${CYAN}vyn --help${NC}\n"
    echo ""
    
    printf "${GREEN}üöÄ Features:${NC}  ${YELLOW}Fast ‚Ä¢ Interactive ‚Ä¢ Professional${NC}\n"
    printf "${GREEN}üéØ Modes:${NC}     ${YELLOW}Remux (fast) ‚Ä¢ Encode (quality)${NC}\n"
    echo ""
    
    printf "${GREEN}Made with ${RED}‚ù§Ô∏è ${GREEN} for the community${NC}\n"
    echo ""
}

# Function to get file info
get_file_info() {
    local file="$1"
    
    print_color "$CYAN" "üìÅ File Information:"
    
    # Skip detailed analysis for dry run with empty/dummy files
    if [[ "$DRY_RUN" == true ]] && [[ ! -s "$file" ]]; then
        echo "  üìÑ File: $(basename "$file")"
        echo "  üíæ Size: Empty file (dry run test)"
        print_info "Skipping detailed analysis for empty test file"
        echo ""
        return 0
    fi
    
    # For dry run mode, if ffprobe fails, show basic info and continue
    if [[ "$DRY_RUN" == true ]]; then
        local file_info
        file_info=$(ffprobe -v quiet -print_format json -show_format -show_streams "$file" 2>/dev/null)
        if [[ -z "$file_info" ]]; then
            echo "  üìÑ File: $(basename "$file")"
            echo "  üíæ Size: $(ls -lh "$file" | awk '{print $5}')"
            echo "  ‚ÑπÔ∏è  Note: Not a valid video file (test file for dry run)"
            echo ""
            return 0
        fi
    fi
    
    # Try to get detailed info with jq, fallback to basic info if jq fails
    if command -v jq &> /dev/null; then
        local file_info
        file_info=$(ffprobe -v quiet -print_format json -show_format -show_streams "$file" 2>/dev/null)
        
        if [[ -n "$file_info" ]]; then
            if ! echo "$file_info" | jq -r '
                .format as $fmt |
                (.streams[] | select(.codec_type=="video")) as $video |
                (.streams[] | select(.codec_type=="audio")) as $audio |
                "  üìÑ File: " + ($fmt.filename | split("/")[-1]) + "\n" +
                "  üì¶ Container: " + $fmt.format_name + "\n" +
                "  ‚è±Ô∏è  Duration: " + (if $fmt.duration then (($fmt.duration | tonumber) | strftime("%H:%M:%S")) else "Unknown" end) + "\n" +
                "  üíæ Size: " + (if $fmt.size then (($fmt.size | tonumber / 1024 / 1024) | floor | tostring) + " MB" else "Unknown" end) + "\n" +
                (if $video then "  üé¨ Video: " + $video.codec_name + " | " + ($video.width | tostring) + "x" + ($video.height | tostring) + " | " + (if $video.r_frame_rate then (($video.r_frame_rate | split("/") | (.[0] | tonumber) / (.[1] | tonumber)) | floor | tostring) + " fps" else "Unknown fps" end) else "  üé¨ Video: No video stream found" end) +
                (if $audio then "\n  üîä Audio: " + $audio.codec_name + " | " + ($audio.channels | tostring) + " channels" else "\n  üîä Audio: No audio stream found" end)
            ' 2>/dev/null; then
                print_fallback_info "$file"
            fi
        else
            print_fallback_info "$file"
        fi
    else
        print_fallback_info "$file"
    fi
    echo ""
}

# Fallback function for basic file info
print_fallback_info() {
    local file="$1"
    echo "  üìÑ File: $(basename "$file")"
    
    if [[ -s "$file" ]]; then
        echo "  üíæ Size: $(ls -lh "$file" | awk '{print $5}')"
        
        if command -v ffprobe &> /dev/null; then
            local duration
            duration=$(ffprobe -v quiet -show_entries format=duration -of csv="p=0" "$file" 2>/dev/null)
            if [[ -n "$duration" ]]; then
                local seconds
                seconds=$(echo "$duration" | awk '{print int($1)}')
                local hours=$((seconds / 3600))
                local minutes=$(((seconds % 3600) / 60))
                local secs=$((seconds % 60))
                printf "  ‚è±Ô∏è  Duration: %02d:%02d:%02d\n" "$hours" "$minutes" "$secs"
            fi
        fi
    else
        echo "  üíæ Size: Empty file"
        if [[ "$DRY_RUN" == true ]]; then
            echo "  ‚ÑπÔ∏è  Note: This is a test file for dry run mode"
        fi
    fi
}

# Function to select operation mode
select_operation_mode() {
    echo ""
    print_color $PURPLE "Select Operation Mode:"
    echo "1) Remux (Fast - just change container, no re-encoding)"
    echo "2) Encode (Slower - full conversion with quality options)"
    echo ""
    while true; do
        read -r -p "Enter your choice (1-2): " choice
        case $choice in
            1)
                OPERATION_MODE="remux"
                print_color $GREEN "Selected: Remux (Fast conversion)"
                break
                ;;
            2)
                OPERATION_MODE="encode"
                print_color $GREEN "Selected: Encode (Full conversion)"
                break
                ;;
            *)
                print_color $RED "Invalid choice. Please enter 1 or 2."
                ;;
        esac
    done
}

# Function to select quality for encoding
select_quality() {
    if [ "$OPERATION_MODE" = "encode" ]; then
        echo ""
        print_color $PURPLE "Select Video Quality:"
        echo "1) High Quality (CRF 18 - Large file size)"
        echo "2) Good Quality (CRF 23 - Balanced)"
        echo "3) Medium Quality (CRF 28 - Smaller file)"
        echo "4) Low Quality (CRF 32 - Very small file)"
        echo "5) Custom CRF value"
        echo ""
        while true; do
            read -r -p "Enter your choice (1-5): " quality_choice
            case $quality_choice in
                1)
                    CRF_VALUE="18"
                    print_color $GREEN "Selected: High Quality (CRF 18)"
                    break
                    ;;
                2)
                    CRF_VALUE="23"
                    print_color $GREEN "Selected: Good Quality (CRF 23)"
                    break
                    ;;
                3)
                    CRF_VALUE="28"
                    print_color $GREEN "Selected: Medium Quality (CRF 28)"
                    break
                    ;;
                4)
                    CRF_VALUE="32"
                    print_color $GREEN "Selected: Low Quality (CRF 32)"
                    break
                    ;;
                5)
                    while true; do
                        read -r -p "Enter CRF value (0-51, lower = better quality): " custom_crf
                        if [[ "$custom_crf" =~ ^[0-9]+$ ]] && [ "$custom_crf" -ge 0 ] && [ "$custom_crf" -le 51 ]; then
                            CRF_VALUE="$custom_crf"
                            print_color $GREEN "Selected: Custom Quality (CRF $custom_crf)"
                            break 2
                        else
                            print_color $RED "Invalid CRF value. Please enter a number between 0-51."
                        fi
                    done
                    ;;
                *)
                    print_color $RED "Invalid choice. Please enter 1-5."
                    ;;
            esac
        done
    fi
}

# Function to format file size in human readable format
format_file_size() {
    local size="$1"
    
    if [[ "$size" -eq 0 ]]; then
        echo "0 B"
    elif [[ "$size" -lt 1024 ]]; then
        echo "${size} B"
    elif [[ "$size" -lt $((1024*1024)) ]]; then
        echo "$((size/1024)) KB"
    elif [[ "$size" -lt $((1024*1024*1024)) ]]; then
        echo "$((size/1024/1024)) MB"
    else
        echo "$((size/1024/1024/1024)) GB"
    fi
}

# Function to validate file format compatibility
validate_file_format() {
    local input="$1"
    local output="$2"
    
    # Get file extension
    local input_ext="${input##*.}"
    local output_ext="${output##*.}"
    
    # Convert to lowercase
    input_ext=$(echo "$input_ext" | tr '[:upper:]' '[:lower:]')
    output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
    
    # Define supported input formats
    local supported_input="mp4 mkv avi mov webm m4v flv 3gp wmv mpg mpeg ts"
    local supported_output="mp4 mkv avi mov webm m4v"
    
    # Check input format
    if [[ ! " $supported_input " =~ " $input_ext " ]]; then
        print_warning "‚ö†Ô∏è  Input format '.$input_ext' may not be fully supported"
        print_info "Supported input formats: $supported_input"
    fi
    
    # Check output format
    if [[ ! " $supported_output " =~ " $output_ext " ]]; then
        print_warning "‚ö†Ô∏è  Output format '.$output_ext' may not be optimal"
        print_info "Recommended output formats: $supported_output"
    fi
    
    return 0
}

# Function to estimate output file size for dry run
estimate_output_size() {
    local input="$1"
    local operation_mode="$2"
    local crf_value="$3"
    local output_ext="$4"
    
    if [[ ! -s "$input" ]]; then
        echo "Unknown (empty test file)"
        return 0
    fi
    
    local input_size
    if [[ "$OSTYPE" == "darwin"* ]]; then
        input_size=$(stat -f%z "$input" 2>/dev/null || echo "0")
    else
        input_size=$(stat -c%s "$input" 2>/dev/null || echo "0")
    fi
    
    if [[ "$input_size" -eq 0 ]]; then
        echo "Unknown"
        return 0
    fi
    
    local estimated_size=$input_size
    
    if [[ "$operation_mode" == "remux" ]]; then
        # Remux: size usually stays very similar (¬±5%)
        estimated_size=$input_size
        echo "~$(( input_size / 1024 / 1024 )) MB (similar to input)"
    else
        # Encode: estimate based on CRF value and format using bash arithmetic
        local compression_percent
        case "$output_ext" in
            "webm")
                # WebM with VP9 is generally more efficient
                case "$crf_value" in
                    1[0-8]) compression_percent=70 ;;  # High quality - 70% of original
                    1[9-5]) compression_percent=50 ;;  # Good quality - 50% of original
                    2[6-2]) compression_percent=35 ;;  # Medium quality - 35% of original
                    *) compression_percent=25 ;;       # Low quality - 25% of original
                esac
                ;;
            *)
                # H.264 compression estimates
                case "$crf_value" in
                    1[0-8]) compression_percent=80 ;;  # High quality - 80% of original
                    1[9-5]) compression_percent=60 ;;  # Good quality - 60% of original
                    2[6-2]) compression_percent=40 ;;  # Medium quality - 40% of original
                    *) compression_percent=30 ;;       # Low quality - 30% of original
                esac
                ;;
        esac
        
        estimated_size=$(( input_size * compression_percent / 100 ))
        local estimated_mb=$((estimated_size / 1024 / 1024))
        local input_mb=$((input_size / 1024 / 1024))
        local savings=$(( 100 - compression_percent ))
        
        echo "~${estimated_mb} MB (estimated ${savings}% smaller)"
    fi
}
do_remux() {
    local input="$1"
    local output="$2"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "üîç DRY RUN: Remux operation preview"
        print_color "$CYAN" "Would execute: ffmpeg -i \"$input\" -c copy \"$output\""
        print_info "üìä Operation: Copy streams without re-encoding"
        print_info "‚ö° Expected speed: Very fast (seconds)"
        print_info "üéØ Quality: Identical to source"
        
        # Show estimated output size
        local output_ext="${output##*.}"
        output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
        local estimated_size=$(estimate_output_size "$input" "remux" "" "$output_ext")
        print_info "üì¶ Estimated output size: $estimated_size"
        return 0
    fi
    
    print_info "üöÄ Starting remux operation..."
    print_color "$CYAN" "Command: ffmpeg -i \"$input\" -c copy \"$output\""
    echo ""
    
    # Record start time for timing
    local start_time=$(date +%s)
    
    # Run FFmpeg in background with progress bar
    ffmpeg -i "$input" -c copy "$output" -y -loglevel error -stats -hide_banner > /tmp/vyn_output.log 2>&1 &
    local ffmpeg_pid=$!
    
    # Show progress bar while FFmpeg runs
    show_progress_bar "$(basename "$input") ‚Üí $(basename "$output")" "$ffmpeg_pid" "Remuxing"
    
    # Wait for FFmpeg to complete and check result
    wait $ffmpeg_pid
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        print_success "‚úÖ Remux completed successfully in ${duration}s!"
        
        # Show file size comparison
        if [[ -f "$input" && -f "$output" ]]; then
            show_file_comparison "$input" "$output"
        fi
    else
        echo ""
        print_error "Remux operation failed!"
        print_info "This might happen if the codecs are not compatible with the output container."
        print_info "Try using encode mode instead."
        if [[ -f /tmp/vyn_output.log ]]; then
            print_info "Error details:"
            cat /tmp/vyn_output.log
        fi
        exit 1
    fi
}

# Function to perform encoding
do_encode() {
    local input="$1"
    local output="$2"
    
    # Determine codec based on output format
    local output_ext="${output##*.}"
    local video_codec=""
    local audio_codec=""
    local extra_params=""
    
    # Convert extension to lowercase for comparison
    output_ext=$(echo "$output_ext" | tr '[:upper:]' '[:lower:]')
    
    case "$output_ext" in
        "mp4"|"m4v")
            video_codec="libx264"
            audio_codec="aac"
            extra_params="-movflags +faststart"  # Optimize for web streaming
            ;;
        "webm")
            video_codec="libvpx-vp9"
            audio_codec="libopus"
            extra_params="-b:v 0 -b:a 128k"  # VBR for VP9
            ;;
        "mkv")
            video_codec="libx264"
            audio_codec="aac"
            ;;
        "avi")
            video_codec="libx264"
            audio_codec="aac"
            ;;
        "mov")
            video_codec="libx264"
            audio_codec="aac"
            extra_params="-movflags +faststart"
            ;;
        "flv")
            video_codec="libx264"
            audio_codec="aac"
            ;;
        "3gp")
            video_codec="libx264"
            audio_codec="aac"
            extra_params="-s 320x240"  # Mobile-friendly resolution
            ;;
        *)
            video_codec="libx264"
            audio_codec="aac"
            print_warning "Unknown output format '$output_ext', using default codecs (H.264 + AAC)"
            print_info "Supported formats: mp4, mkv, webm, avi, mov, flv, m4v, 3gp"
            ;;
    esac
    
    print_info "üé¨ Starting encode operation..."
    print_color "$CYAN" "üìº Video Codec: $video_codec | üîä Audio Codec: $audio_codec | üéØ CRF: $CRF_VALUE"
    print_color "$CYAN" "Command: ffmpeg -i \"$input\" -c:v $video_codec -crf $CRF_VALUE -c:a $audio_codec $extra_params \"$output\""
    echo ""
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "üîç DRY RUN: Encode operation preview"
        print_info "üìä Video Codec: $video_codec (CRF $CRF_VALUE)"
        print_info "üîä Audio Codec: $audio_codec"
        print_info "‚ö° Expected speed: Depends on file size and system"
        print_info "üéØ Quality: Based on CRF setting"
        if [[ -n "$extra_params" ]]; then
            print_info "üîß Extra parameters: $extra_params"
        fi
        
        # Show estimated output size
        local estimated_size=$(estimate_output_size "$input" "encode" "$CRF_VALUE" "$output_ext")
        print_info "üì¶ Estimated output size: $estimated_size"
        return 0
    fi
    
    # Show conversion progress indicator
    print_info "üöÄ Starting video encoding..."
    print_info "üìä Monitor the progress below:"
    echo ""
    
    # Build the command with proper parameters
    local cmd=(
        ffmpeg -i "$input"
        -c:v "$video_codec"
        -crf "$CRF_VALUE"
        -c:a "$audio_codec"
        -y
        -loglevel info
        -stats
        -hide_banner
    )
    
    # Add extra parameters if any
    if [[ -n "$extra_params" ]]; then
        # shellcheck disable=SC2206
        cmd+=($extra_params)
    fi
    
    cmd+=("$output")
    
    # Record start time for timing
    local start_time=$(date +%s)
    
    # Run FFmpeg in background with progress bar
    "${cmd[@]}" -loglevel error -stats > /tmp/vyn_output.log 2>&1 &
    local ffmpeg_pid=$!
    
    # Show progress bar while FFmpeg runs
    show_progress_bar "$(basename "$input") ‚Üí $(basename "$output")" "$ffmpeg_pid" "Encoding"
    
    # Wait for FFmpeg to complete and check result
    wait $ffmpeg_pid
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        print_success "‚úÖ Encoding completed successfully in ${duration}s!"
        
        # Show file size comparison if input exists
        if [[ -f "$input" && -f "$output" ]]; then
            show_file_comparison "$input" "$output"
        fi
    else
        echo ""
        print_error "Encoding operation failed!"
        print_info "Check the error messages above for details."
        if [[ -f /tmp/vyn_output.log ]]; then
            print_info "Error details:"
            cat /tmp/vyn_output.log
        fi
        exit 1
    fi
}

# Function to show file size comparison
show_file_comparison() {
    local input="$1"
    local output="$2"
    
    echo ""
    print_info "üìä File Size Comparison:"
    
    # Get file sizes
    local input_size=$(stat -c%s "$input" 2>/dev/null || echo "0")
    local output_size=$(stat -c%s "$output" 2>/dev/null || echo "0")
    
    # Convert to human readable format
    local input_readable=$(format_file_size "$input_size")
    local output_readable=$(format_file_size "$output_size")
    
    print_info "   Original:  $input_readable"
    print_info "   Converted: $output_readable"
    
    # Calculate compression ratio if both sizes are available
    if [[ "$input_size" -gt 0 && "$output_size" -gt 0 ]]; then
        local ratio=$((output_size * 100 / input_size))
        local savings=$((100 - ratio))
        
        if [[ $ratio -lt 100 ]]; then
            print_success "   üíæ Space saved: ${savings}%% (compression ratio: ${ratio}%%)"
        else
            local increase=$((ratio - 100))
            print_warning "   üìà File size increased by ${increase}%%"
        fi
    fi
    echo ""
}

# Function to show conversion summary
show_summary() {
    local input="$1"
    local output="$2"
    
    if [[ -f "$output" ]]; then
        echo ""
        print_color "$GREEN" "üìä Conversion Summary:"
        
        local input_size_human
        local output_size_human
        input_size_human=$(ls -lh "$input" | awk '{print $5}')
        output_size_human=$(ls -lh "$output" | awk '{print $5}')
        
        echo "  üì• Input:  $input_size_human - $input"
        echo "  üì§ Output: $output_size_human - $output"
        
        # Calculate size difference with better cross-platform compatibility
        local input_size
        local output_size
        
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            input_size=$(stat -f%z "$input" 2>/dev/null)
            output_size=$(stat -f%z "$output" 2>/dev/null)
        else
            # Linux and others
            input_size=$(stat -c%s "$input" 2>/dev/null)
            output_size=$(stat -c%s "$output" 2>/dev/null)
        fi
        
        if [[ -n "$input_size" && -n "$output_size" ]]; then
            local size_diff=$((output_size - input_size))
            local percent_change
            
            if [[ "$input_size" -gt 0 ]]; then
                percent_change=$(( (size_diff * 100) / input_size ))
                
                if [[ $size_diff -gt 0 ]]; then
                    local size_diff_mb=$((size_diff / 1024 / 1024))
                    print_warning "  üìà Size change: +${percent_change}%% (+${size_diff_mb}MB larger)"
                elif [[ $size_diff -lt 0 ]]; then
                    local size_diff_mb=$(( (-size_diff) / 1024 / 1024 ))
                    print_success "  üìâ Size change: ${percent_change}%% (-${size_diff_mb}MB smaller)"
                else
                    print_info "  ‚û°Ô∏è  Size change: No change"
                fi
            fi
        fi
    fi
}

# Main function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --no-color)
                USE_COLOR=false
                init_colors
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Use --help for usage information."
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Show help if no arguments provided
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    # Check if required dependencies are installed
    check_dependencies
    
    # Get input and output files
    local input_file="$1"
    local output_file="${2:-}"
    
    # Validate input file
    if [[ ! -f "$input_file" ]]; then
        print_error "Input file '$input_file' does not exist!"
        exit 1
    fi
    
    # Check if input file is readable
    if [[ ! -r "$input_file" ]]; then
        print_error "Input file '$input_file' is not readable!"
        print_info "Check file permissions or if the file is being used by another process."
        exit 1
    fi
    
    # If output file not provided, prompt for it
    if [[ -z "$output_file" ]]; then
        echo ""
        read -r -p "Enter output filename: " output_file
        if [[ -z "$output_file" ]]; then
            print_error "Output filename cannot be empty!"
            exit 1
        fi
    fi
    
    # Validate output directory exists and is writable
    local output_dir
    output_dir="$(dirname "$output_file")"
    if [[ ! -d "$output_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            print_info "Would create directory: $output_dir"
        else
            print_info "Creating output directory: $output_dir"
            if ! mkdir -p "$output_dir" 2>/dev/null; then
                print_error "Failed to create output directory '$output_dir'!"
                print_info "Check parent directory permissions."
                exit 1
            fi
            print_success "‚úÖ Directory created successfully"
        fi
    fi
    
    if [[ ! "$DRY_RUN" == true ]] && [[ ! -w "$output_dir" ]]; then
        print_error "Output directory '$output_dir' is not writable!"
        print_info "Check directory permissions."
        exit 1
    fi
    
    # Check if output file already exists
    if [[ -f "$output_file" ]]; then
        echo ""
        print_warning "Output file '$output_file' already exists!"
        read -r -p "Do you want to overwrite it? (y/N): " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
            print_info "Conversion cancelled."
            exit 0
        fi
    fi
    
    # Show file information
    get_file_info "$input_file"
    
    # Validate file format compatibility
    echo ""
    validate_file_format "$input_file" "$output_file"
    echo ""
    
    # Select operation mode
    select_operation_mode
    
    # Select quality if encoding
    select_quality
    
    # Confirm operation
    echo ""
    if [[ "$DRY_RUN" == true ]]; then
        print_color "$BLUE" "üîç DRY RUN - Preview Mode"
    else
        print_color "$PURPLE" "üîß Conversion Details:"
    fi
    echo "  üì• Input:     $input_file"
    echo "  üì§ Output:    $output_file"
    echo "  ‚öôÔ∏è  Mode:      $OPERATION_MODE"
    if [[ "$OPERATION_MODE" == "encode" ]]; then
        echo "  üéØ Quality:   CRF $CRF_VALUE"
    fi
    if [[ "$DRY_RUN" == true ]]; then
        echo ""
        print_info "This is a preview - no files will be modified"
        read -r -p "Continue with preview? (Y/n): " confirm
    else
        echo ""
        read -r -p "Proceed with conversion? (Y/n): " confirm
    fi
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            print_info "Preview cancelled."
        else
            print_info "Conversion cancelled."
        fi
        exit 0
    fi
    
    # Record start time
    local start_time
    start_time=$(date +%s)
    
    # Perform conversion or preview
    if [[ "$OPERATION_MODE" == "remux" ]]; then
        do_remux "$input_file" "$output_file"
    else
        do_encode "$input_file" "$output_file"
    fi
    
    # Skip summary and timing for dry run
    if [[ "$DRY_RUN" == true ]]; then
        print_success "üîç Dry run completed successfully!"
        print_info "Use the same command without --dry-run to perform the actual conversion."
        exit 0
    fi
    
    # Calculate duration
    local end_time
    local duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    # Show summary
    show_summary "$input_file" "$output_file"
    
    # Format duration nicely
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    
    if [[ $hours -gt 0 ]]; then
        print_success "üéâ Conversion completed in ${hours}h ${minutes}m ${seconds}s!"
    elif [[ $minutes -gt 0 ]]; then
        print_success "üéâ Conversion completed in ${minutes}m ${seconds}s!"
    else
        print_success "üéâ Conversion completed in ${seconds}s!"
    fi
}

# Run main function with all arguments
main "$@"
